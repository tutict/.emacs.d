"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.MdTableOfContentsProvider = exports.TableOfContents = void 0;
const vscode_uri_1 = require("vscode-uri");
const logging_1 = require("./logging");
const slugify_1 = require("./slugify");
const range_1 = require("./types/range");
const textDocument_1 = require("./types/textDocument");
const dispose_1 = require("./util/dispose");
const workspaceCache_1 = require("./workspaceCache");
class TableOfContents {
    constructor(entries, slugifier) {
        this.entries = entries;
        this.slugifier = slugifier;
    }
    static async create(parser, document) {
        const entries = await this.buildToc(parser, document);
        return new TableOfContents(entries, parser.slugifier);
    }
    static async createForContainingDoc(parser, workspace, document) {
        const context = workspace.getContainingDocument?.(vscode_uri_1.URI.parse(document.uri));
        if (context) {
            const entries = [];
            await Promise.all(Array.from(context.children, async (cell) => {
                const doc = await workspace.openMarkdownDocument(cell.uri);
                if (doc) {
                    entries.push(...(await this.buildToc(parser, doc)));
                }
            }));
            return new TableOfContents(entries, parser.slugifier);
        }
        return this.create(parser, document);
    }
    static async buildToc(parser, document) {
        const docUri = vscode_uri_1.URI.parse(document.uri);
        const toc = [];
        const tokens = await parser.tokenize(document);
        const existingSlugEntries = new Map();
        for (const heading of tokens.filter(token => token.type === 'heading_open')) {
            if (!heading.map) {
                continue;
            }
            const lineNumber = heading.map[0];
            const line = (0, textDocument_1.getLine)(document, lineNumber);
            let slug = parser.slugifier.fromHeading(line);
            const existingSlugEntry = existingSlugEntries.get(slug.value);
            if (existingSlugEntry) {
                ++existingSlugEntry.count;
                slug = parser.slugifier.fromHeading(slug.value + '-' + existingSlugEntry.count);
            }
            else {
                existingSlugEntries.set(slug.value, { count: 0 });
            }
            const headerLocation = {
                uri: docUri.toString(),
                range: (0, range_1.makeRange)(lineNumber, 0, lineNumber, line.length)
            };
            const headerTextLocation = {
                uri: docUri.toString(),
                range: (0, range_1.makeRange)(lineNumber, line.match(/^#+\s*/)?.[0].length ?? 0, lineNumber, line.length - (line.match(/\s*#*$/)?.[0].length ?? 0))
            };
            toc.push({
                slug,
                text: TableOfContents.getHeaderText(line),
                level: TableOfContents.getHeaderLevel(heading.markup),
                line: lineNumber,
                sectionLocation: headerLocation,
                headerLocation,
                headerTextLocation
            });
        }
        // Get full range of section
        return toc.map((entry, startIndex) => {
            let end = undefined;
            for (let i = startIndex + 1; i < toc.length; ++i) {
                if (toc[i].level <= entry.level) {
                    end = toc[i].line - 1;
                    break;
                }
            }
            const endLine = end ?? document.lineCount - 1;
            return {
                ...entry,
                sectionLocation: {
                    uri: docUri.toString(),
                    range: (0, range_1.makeRange)(entry.sectionLocation.range.start, { line: endLine, character: (0, textDocument_1.getLine)(document, endLine).length })
                }
            };
        });
    }
    static getHeaderLevel(markup) {
        if (markup === '=') {
            return 1;
        }
        else if (markup === '-') {
            return 2;
        }
        else { // '#', '##', ...
            return markup.length;
        }
    }
    static getHeaderText(header) {
        return header.replace(/^\s*#+\s*(.*?)(\s+#+)?$/, (_, word) => word.trim());
    }
    lookup(fragment) {
        const slug = this.slugifier.fromHeading(fragment);
        return this.entries.find(entry => entry.slug.equals(slug));
    }
}
exports.TableOfContents = TableOfContents;
TableOfContents.empty = new TableOfContents([], slugify_1.githubSlugifier);
class MdTableOfContentsProvider extends dispose_1.Disposable {
    constructor(parser, workspace, logger) {
        super();
        this.logger = logger;
        this._cache = this._register(new workspaceCache_1.MdDocumentInfoCache(workspace, doc => {
            this.logger.log(logging_1.LogLevel.Debug, 'TableOfContentsProvider', `create - ${doc.uri}`);
            return TableOfContents.create(parser, doc);
        }));
    }
    async get(resource) {
        return await this._cache.get(resource) ?? TableOfContents.empty;
    }
    getForDocument(doc) {
        return this._cache.getForDocument(doc);
    }
}
exports.MdTableOfContentsProvider = MdTableOfContentsProvider;
//# sourceMappingURL=tableOfContents.js.map