"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFilePathRange = exports.getLinkRenameText = exports.MdRenameProvider = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const path = require("path");
const nls = require("vscode-nls");
const vscode_uri_1 = require("vscode-uri");
const config_1 = require("../config");
const position_1 = require("../types/position");
const range_1 = require("../types/range");
const dispose_1 = require("../util/dispose");
const editBuilder_1 = require("../util/editBuilder");
const schemes_1 = require("../util/schemes");
const workspace_1 = require("../workspace");
const documentLinks_1 = require("./documentLinks");
const references_1 = require("./references");
const localize = nls.loadMessageBundle();
function tryDecodeUri(str) {
    try {
        return decodeURI(str);
    }
    catch {
        return str;
    }
}
class MdRenameProvider extends dispose_1.Disposable {
    constructor(configuration, workspace, referencesProvider, slugifier) {
        super();
        this.configuration = configuration;
        this.workspace = workspace;
        this.referencesProvider = referencesProvider;
        this.slugifier = slugifier;
        this.renameNotSupportedText = localize('rename.notSupported', 'Rename not supported at location');
    }
    async prepareRename(document, position, token) {
        const allRefsInfo = await this.getAllReferences(document, position, token);
        if (token.isCancellationRequested) {
            return undefined;
        }
        if (!allRefsInfo || !allRefsInfo.references.length) {
            throw new Error(this.renameNotSupportedText);
        }
        const triggerRef = allRefsInfo.triggerRef;
        switch (triggerRef.kind) {
            case references_1.MdReferenceKind.Header: {
                return { range: triggerRef.headerTextLocation.range, placeholder: triggerRef.headerText };
            }
            case references_1.MdReferenceKind.Link: {
                if (triggerRef.link.kind === documentLinks_1.MdLinkKind.Definition) {
                    // We may have been triggered on the ref or the definition itself
                    if ((0, range_1.rangeContains)(triggerRef.link.ref.range, position)) {
                        return { range: triggerRef.link.ref.range, placeholder: triggerRef.link.ref.text };
                    }
                }
                if (triggerRef.link.href.kind === documentLinks_1.HrefKind.External) {
                    return { range: triggerRef.link.source.hrefRange, placeholder: document.getText(triggerRef.link.source.hrefRange) };
                }
                // See if we are renaming the fragment or the path
                const { fragmentRange } = triggerRef.link.source;
                if (fragmentRange && (0, range_1.rangeContains)(fragmentRange, position)) {
                    const declaration = this.findHeaderDeclaration(allRefsInfo.references);
                    if (declaration) {
                        return { range: fragmentRange, placeholder: declaration.headerText };
                    }
                    return { range: fragmentRange, placeholder: document.getText(fragmentRange) };
                }
                const range = getFilePathRange(triggerRef.link);
                if (!range) {
                    throw new Error(this.renameNotSupportedText);
                }
                return { range, placeholder: tryDecodeUri(document.getText(range)) };
            }
        }
    }
    findHeaderDeclaration(references) {
        return references.find(ref => ref.isDefinition && ref.kind === references_1.MdReferenceKind.Header);
    }
    async provideRenameEdits(document, position, newName, token) {
        return (await this.provideRenameEditsImpl(document, position, newName, token));
    }
    async provideRenameEditsImpl(document, position, newName, token) {
        const allRefsInfo = await this.getAllReferences(document, position, token);
        if (token.isCancellationRequested || !allRefsInfo || !allRefsInfo.references.length) {
            return undefined;
        }
        const triggerRef = allRefsInfo.triggerRef;
        if (triggerRef.kind === references_1.MdReferenceKind.Link && ((triggerRef.link.kind === documentLinks_1.MdLinkKind.Definition && (0, range_1.rangeContains)(triggerRef.link.ref.range, position)) || triggerRef.link.href.kind === documentLinks_1.HrefKind.Reference)) {
            return this.renameReferenceLinks(allRefsInfo, newName);
        }
        else if (triggerRef.kind === references_1.MdReferenceKind.Link && triggerRef.link.href.kind === documentLinks_1.HrefKind.External) {
            return this.renameExternalLink(allRefsInfo, newName);
        }
        else if (triggerRef.kind === references_1.MdReferenceKind.Header || (triggerRef.kind === references_1.MdReferenceKind.Link && triggerRef.link.source.fragmentRange && (0, range_1.rangeContains)(triggerRef.link.source.fragmentRange, position) && (triggerRef.link.kind === documentLinks_1.MdLinkKind.Definition || triggerRef.link.kind === documentLinks_1.MdLinkKind.Link && triggerRef.link.href.kind === documentLinks_1.HrefKind.Internal))) {
            return this.renameFragment(allRefsInfo, newName);
        }
        else if (triggerRef.kind === references_1.MdReferenceKind.Link && !(triggerRef.link.source.fragmentRange && (0, range_1.rangeContains)(triggerRef.link.source.fragmentRange, position)) && (triggerRef.link.kind === documentLinks_1.MdLinkKind.Link || triggerRef.link.kind === documentLinks_1.MdLinkKind.Definition) && triggerRef.link.href.kind === documentLinks_1.HrefKind.Internal) {
            return this.renameFilePath(triggerRef.link.source.resource, triggerRef.link.href, allRefsInfo, newName);
        }
        return undefined;
    }
    async renameFilePath(triggerDocument, triggerHref, allRefsInfo, newName) {
        const builder = new editBuilder_1.WorkspaceEditBuilder();
        const targetUri = await (0, workspace_1.statLinkToMarkdownFile)(this.configuration, this.workspace, triggerHref.path) ?? triggerHref.path;
        const rawNewFilePath = (0, documentLinks_1.resolveDocumentLink)(triggerDocument, newName, this.workspace);
        if (!rawNewFilePath) {
            return builder.getEdit();
        }
        let resolvedNewFilePath = rawNewFilePath.path;
        if (!vscode_uri_1.Utils.extname(resolvedNewFilePath)) {
            // If the newly entered path doesn't have a file extension but the original link did
            // tack on a .md file extension
            if (vscode_uri_1.Utils.extname(targetUri)) {
                resolvedNewFilePath = resolvedNewFilePath.with({
                    path: resolvedNewFilePath.path + '.' + (this.configuration.markdownFileExtensions[0] ?? config_1.defaultMarkdownFileExtension)
                });
            }
        }
        // First rename the file
        if (await this.workspace.stat(targetUri)) {
            builder.renameFile(targetUri, resolvedNewFilePath);
        }
        // Then update all refs to it
        for (const ref of allRefsInfo.references) {
            if (ref.kind === references_1.MdReferenceKind.Link) {
                // Try to preserve style of existing links
                const newLinkText = getLinkRenameText(this.workspace, ref.link.source, rawNewFilePath.path, newName.startsWith('./') || newName.startsWith('.\\'));
                builder.replace(ref.link.source.resource, getFilePathRange(ref.link), encodeURI((newLinkText ?? newName).replace(/\\/g, '/')));
            }
        }
        return builder.getEdit();
    }
    renameFragment(allRefsInfo, newName) {
        const slug = this.slugifier.fromHeading(newName).value;
        const builder = new editBuilder_1.WorkspaceEditBuilder();
        for (const ref of allRefsInfo.references) {
            switch (ref.kind) {
                case references_1.MdReferenceKind.Header:
                    builder.replace(vscode_uri_1.URI.parse(ref.location.uri), ref.headerTextLocation.range, newName);
                    break;
                case references_1.MdReferenceKind.Link:
                    builder.replace(ref.link.source.resource, ref.link.source.fragmentRange ?? ref.location.range, !ref.link.source.fragmentRange || ref.link.href.kind === documentLinks_1.HrefKind.External ? newName : slug);
                    break;
            }
        }
        return builder.getEdit();
    }
    renameExternalLink(allRefsInfo, newName) {
        const builder = new editBuilder_1.WorkspaceEditBuilder();
        for (const ref of allRefsInfo.references) {
            if (ref.kind === references_1.MdReferenceKind.Link) {
                builder.replace(ref.link.source.resource, ref.location.range, newName);
            }
        }
        return builder.getEdit();
    }
    renameReferenceLinks(allRefsInfo, newName) {
        const builder = new editBuilder_1.WorkspaceEditBuilder();
        for (const ref of allRefsInfo.references) {
            if (ref.kind === references_1.MdReferenceKind.Link) {
                if (ref.link.kind === documentLinks_1.MdLinkKind.Definition) {
                    builder.replace(ref.link.source.resource, ref.link.ref.range, newName);
                }
                else {
                    builder.replace(ref.link.source.resource, ref.link.source.fragmentRange ?? ref.location.range, newName);
                }
            }
        }
        return builder.getEdit();
    }
    async getAllReferences(document, position, token) {
        const version = document.version;
        if (this.cachedRefs
            && this.cachedRefs.resource.fsPath === vscode_uri_1.URI.parse(document.uri).fsPath
            && this.cachedRefs.version === document.version
            && (0, position_1.arePositionsEqual)(this.cachedRefs.position, position)) {
            return this.cachedRefs;
        }
        const references = await this.referencesProvider.getReferencesAtPosition(document, position, token);
        const triggerRef = references.find(ref => ref.isTriggerLocation);
        if (!triggerRef) {
            return undefined;
        }
        this.cachedRefs = {
            resource: vscode_uri_1.URI.parse(document.uri),
            version,
            position,
            references,
            triggerRef
        };
        return this.cachedRefs;
    }
}
exports.MdRenameProvider = MdRenameProvider;
function getLinkRenameText(workspace, source, newPath, preferDotSlash = false) {
    if (source.hrefText.startsWith('/')) {
        const root = (0, documentLinks_1.resolveDocumentLink)(source.resource, '/', workspace);
        if (!root) {
            return undefined;
        }
        return '/' + path.relative(root.path.toString(true), newPath.toString(true));
    }
    const rootDir = vscode_uri_1.Utils.dirname(source.resource);
    if (rootDir.scheme === newPath.scheme && rootDir.scheme !== schemes_1.Schemes.untitled) {
        let newLink = path.relative(rootDir.toString(true), newPath.toString(true));
        if (preferDotSlash && !newLink.startsWith('../') || preferDotSlash && !newLink.startsWith('..\\')) {
            newLink = './' + newLink;
        }
        return newLink;
    }
    return undefined;
}
exports.getLinkRenameText = getLinkRenameText;
function getFilePathRange(link) {
    if (link.source.fragmentRange) {
        return (0, range_1.modifyRange)(link.source.hrefRange, undefined, (0, position_1.translatePosition)(link.source.fragmentRange.start, { characterDelta: -1 }));
    }
    return link.source.hrefRange;
}
exports.getFilePathRange = getFilePathRange;
//# sourceMappingURL=rename.js.map