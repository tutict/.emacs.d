"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MdFileRenameProvider = void 0;
const vscode_uri_1 = require("vscode-uri");
const config_1 = require("../config");
const dispose_1 = require("../util/dispose");
const editBuilder_1 = require("../util/editBuilder");
const file_1 = require("../util/file");
const path_1 = require("../util/path");
const documentLinks_1 = require("./documentLinks");
const references_1 = require("./references");
const rename_1 = require("./rename");
const path = require("path");
class MdFileRenameProvider extends dispose_1.Disposable {
    constructor(config, workspace, linkCache, referencesProvider) {
        super();
        this.config = config;
        this.workspace = workspace;
        this.linkCache = linkCache;
        this.referencesProvider = referencesProvider;
    }
    async getRenameFilesInWorkspaceEdit(edits, token) {
        const builder = new editBuilder_1.WorkspaceEditBuilder();
        for (const edit of edits) {
            const stat = await this.workspace.stat(edit.newUri);
            if (stat?.isDirectory) {
                await this.addDirectoryRenameEdits(edit, builder, token);
            }
            else {
                await this.addSingleFileRenameEdits(edit, builder, token);
            }
            if (token.isCancellationRequested) {
                return undefined;
            }
        }
        return builder.getEdit();
    }
    async addSingleFileRenameEdits(edit, builder, token) {
        // Update all references to the file
        await this.addEditsForReferencesToFile(edit, builder, token);
        if (token.isCancellationRequested) {
            return;
        }
        // If the file moved was markdown, we also need to update links in the file itself
        await this.tryAddEditsInSelf(edit, builder);
        if (token.isCancellationRequested) {
            return;
        }
    }
    async addDirectoryRenameEdits(edit, builder, token) {
        // First update every link that points to something in the moved dir
        const allLinksInWorkspace = await this.linkCache.entries();
        if (token.isCancellationRequested) {
            return;
        }
        for (const [docUri, links] of allLinksInWorkspace) {
            for (const link of links) {
                if (link.href.kind !== documentLinks_1.HrefKind.Internal) {
                    continue;
                }
                // Update links to the moved dir
                if ((0, path_1.isParentDir)(edit.oldUri, link.href.path)) {
                    const relative = path.relative(edit.oldUri.path, link.href.path.path);
                    const newUri = edit.newUri.with({
                        path: path.join(edit.newUri.path, relative)
                    });
                    this.addLinkRenameEdit(docUri, link, newUri, builder);
                }
                // If the link was within a file in the moved dir but traversed out of it, we also need to update the path
                if (link.source.pathText.startsWith('..') && (0, path_1.isParentDir)(edit.newUri, docUri)) {
                    // Resolve the link relative to the old file path
                    const oldDocUri = docUri.with({
                        path: vscode_uri_1.Utils.joinPath(edit.oldUri, path.relative(edit.newUri.path, docUri.path)).path
                    });
                    const oldLink = (0, documentLinks_1.resolveDocumentLink)(oldDocUri, link.source.hrefText, this.workspace);
                    if (oldLink && !(0, path_1.isParentDir)(edit.oldUri, oldLink.path)) {
                        const rootDir = vscode_uri_1.Utils.dirname(docUri);
                        const newPath = path.relative(rootDir.path, oldLink.path.path);
                        builder.replace(docUri, (0, rename_1.getFilePathRange)(link), encodeURI(newPath.replace(/\\/g, '/')));
                    }
                }
            }
        }
    }
    /**
     * Try to add edits for when a markdown file has been renamed.
     * In this case we also need to update links within the file.
     */
    async tryAddEditsInSelf(edit, builder) {
        if (!(0, file_1.looksLikeMarkdownPath)(this.config, edit.newUri)) {
            return;
        }
        if ((0, config_1.isExcludedPath)(this.config, edit.newUri)) {
            return;
        }
        const doc = await this.workspace.openMarkdownDocument(edit.newUri);
        if (!doc) {
            return;
        }
        const links = (await this.linkCache.getForDocs([doc]))[0];
        for (const link of links) {
            this.addEditsForLinksInSelf(link, edit, builder);
        }
    }
    addEditsForLinksInSelf(link, edit, builder) {
        if (link.href.kind !== documentLinks_1.HrefKind.Internal) {
            return;
        }
        if (link.source.hrefText.startsWith('/')) {
            // We likely don't need to update anything since an absolute path is used
        }
        else {
            // Resolve the link relative to the old file path
            const oldLink = (0, documentLinks_1.resolveDocumentLink)(edit.oldUri, link.source.hrefText, this.workspace);
            if (oldLink) {
                const rootDir = vscode_uri_1.Utils.dirname(edit.newUri);
                const newPath = path.relative(rootDir.toString(true), oldLink.path.toString(true));
                builder.replace(edit.newUri, (0, rename_1.getFilePathRange)(link), encodeURI(newPath.replace(/\\/g, '/')));
            }
        }
    }
    /**
     * Update links across the workspace for the new file name
     */
    async addEditsForReferencesToFile(edit, builder, token) {
        if ((0, config_1.isExcludedPath)(this.config, edit.newUri)) {
            return;
        }
        const refs = await this.referencesProvider.getReferencesToFileInWorkspace(edit.oldUri, token);
        if (token.isCancellationRequested) {
            return undefined;
        }
        for (const ref of refs) {
            if (ref.kind === references_1.MdReferenceKind.Link) {
                this.addLinkRenameEdit(vscode_uri_1.URI.parse(ref.location.uri), ref.link, edit.newUri, builder);
            }
        }
    }
    async addLinkRenameEdit(doc, link, newUri, builder) {
        if (link.href.kind !== documentLinks_1.HrefKind.Internal) {
            return;
        }
        let newFilePath = newUri;
        // If the original markdown link did not use a file extension, remove ours too
        if (!vscode_uri_1.Utils.extname(link.href.path)) {
            const editExt = vscode_uri_1.Utils.extname(newUri);
            if (this.config.markdownFileExtensions.includes(editExt.replace('.', ''))) {
                newFilePath = newUri.with({
                    path: newUri.path.slice(0, newUri.path.length - editExt.length)
                });
            }
        }
        const newLinkText = (0, rename_1.getLinkRenameText)(this.workspace, link.source, newFilePath, link.source.pathText.startsWith('.'));
        if (typeof newLinkText === 'string') {
            builder.replace(doc, (0, rename_1.getFilePathRange)(link), encodeURI(newLinkText.replace(/\\/g, '/')));
        }
    }
}
exports.MdFileRenameProvider = MdFileRenameProvider;
//# sourceMappingURL=fileRename.js.map