"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWorkspaceLinkCache = exports.MdLinkProvider = exports.LinkDefinitionSet = exports.MdLinkComputer = exports.MdLinkKind = exports.resolveDocumentLink = exports.HrefKind = void 0;
const nls = require("vscode-nls");
const vscode_uri_1 = require("vscode-uri");
const logging_1 = require("../logging");
const position_1 = require("../types/position");
const range_1 = require("../types/range");
const textDocument_1 = require("../types/textDocument");
const arrays_1 = require("../util/arrays");
const cancellation_1 = require("../util/cancellation");
const dispose_1 = require("../util/dispose");
const string_1 = require("../util/string");
const workspace_1 = require("../workspace");
const workspaceCache_1 = require("../workspaceCache");
const localize = nls.loadMessageBundle();
var HrefKind;
(function (HrefKind) {
    HrefKind[HrefKind["External"] = 1] = "External";
    HrefKind[HrefKind["Internal"] = 2] = "Internal";
    HrefKind[HrefKind["Reference"] = 3] = "Reference";
})(HrefKind = exports.HrefKind || (exports.HrefKind = {}));
function resolveLink(document, link, workspace) {
    const cleanLink = stripAngleBrackets(link);
    if (/^[a-z\-][a-z\-]+:/i.test(cleanLink)) {
        // Looks like a uri
        return { kind: HrefKind.External, uri: vscode_uri_1.URI.parse(cleanLink) };
    }
    const resolved = resolveDocumentLink(vscode_uri_1.URI.parse(document.uri), link, workspace);
    if (!resolved) {
        return undefined;
    }
    return {
        kind: HrefKind.Internal,
        path: resolved.path,
        fragment: resolved.fragment,
    };
}
function resolveDocumentLink(inputDocument, link, workspace) {
    // Assume it must be an relative or absolute file path
    // Use a fake scheme to avoid parse warnings
    const tempUri = vscode_uri_1.URI.parse(`vscode-resource:${link}`);
    const docUri = workspace.getContainingDocument?.(inputDocument)?.uri ?? inputDocument;
    let resourceUri;
    if (!tempUri.path) {
        resourceUri = docUri;
    }
    else if (tempUri.path[0] === '/') {
        const root = (0, workspace_1.getWorkspaceFolder)(workspace, docUri);
        if (root) {
            resourceUri = vscode_uri_1.Utils.joinPath(root, tempUri.path);
        }
    }
    else {
        if (docUri.scheme === 'untitled') {
            const root = (0, workspace_1.getWorkspaceFolder)(workspace, docUri);
            if (root) {
                resourceUri = vscode_uri_1.Utils.joinPath(root, tempUri.path);
            }
        }
        else {
            const base = vscode_uri_1.Utils.dirname(docUri);
            resourceUri = vscode_uri_1.Utils.joinPath(base, tempUri.path);
        }
    }
    if (!resourceUri) {
        return undefined;
    }
    return {
        path: resourceUri.with({ fragment: '' }),
        fragment: tempUri.fragment,
    };
}
exports.resolveDocumentLink = resolveDocumentLink;
var MdLinkKind;
(function (MdLinkKind) {
    MdLinkKind[MdLinkKind["Link"] = 1] = "Link";
    MdLinkKind[MdLinkKind["Definition"] = 2] = "Definition";
})(MdLinkKind = exports.MdLinkKind || (exports.MdLinkKind = {}));
function extractDocumentLink(document, pre, rawLink, matchIndex, fullMatch, workspace) {
    const isAngleBracketLink = rawLink.startsWith('<');
    const link = stripAngleBrackets(rawLink);
    let linkTarget;
    try {
        linkTarget = resolveLink(document, link, workspace);
    }
    catch {
        return undefined;
    }
    if (!linkTarget) {
        return undefined;
    }
    const linkStart = document.positionAt(matchIndex);
    const linkEnd = (0, position_1.translatePosition)(linkStart, { characterDelta: fullMatch.length });
    const hrefStart = (0, position_1.translatePosition)(linkStart, { characterDelta: pre.length + (isAngleBracketLink ? 1 : 0) });
    const hrefEnd = (0, position_1.translatePosition)(hrefStart, { characterDelta: link.length });
    return {
        kind: MdLinkKind.Link,
        href: linkTarget,
        source: {
            hrefText: link,
            resource: vscode_uri_1.URI.parse(document.uri),
            range: { start: linkStart, end: linkEnd },
            hrefRange: { start: hrefStart, end: hrefEnd },
            ...getLinkSourceFragmentInfo(document, link, hrefStart, hrefEnd),
        }
    };
}
function getFragmentRange(text, start, end) {
    const index = text.indexOf('#');
    if (index < 0) {
        return undefined;
    }
    return { start: (0, position_1.translatePosition)(start, { characterDelta: index + 1 }), end };
}
function getLinkSourceFragmentInfo(document, link, linkStart, linkEnd) {
    const fragmentRange = getFragmentRange(link, linkStart, linkEnd);
    return {
        pathText: document.getText({ start: linkStart, end: fragmentRange ? (0, position_1.translatePosition)(fragmentRange.start, { characterDelta: -1 }) : linkEnd }),
        fragmentRange,
    };
}
const angleBracketLinkRe = /^<(.*)>$/;
/**
 * Used to strip brackets from the markdown link
 *
 * <http://example.com> will be transformed to http://example.com
*/
function stripAngleBrackets(link) {
    return link.replace(angleBracketLinkRe, '$1');
}
/**
 * Matches `[text](link)` or `[text](<link>)`
 */
const linkPattern = new RegExp(
// text
(0, string_1.r) `(\[` + // open prefix match -->
    /**/ (0, string_1.r) `(?:` +
    /*****/ (0, string_1.r) `[^\[\]\\]|` + // Non-bracket chars, or...
    /*****/ (0, string_1.r) `\\.|` + // Escaped char, or...
    /*****/ (0, string_1.r) `\[[^\[\]]*\]` + // Matched bracket pair
    /**/ (0, string_1.r) `)*` +
    (0, string_1.r) `\]` +
    // Destination
    (0, string_1.r) `\(\s*)` + // <-- close prefix match
    /**/ (0, string_1.r) `(` +
    /*****/ (0, string_1.r) `[^\s\(\)\<](?:[^\s\(\)]|\([^\s\(\)]*?\))*|` + // Link without whitespace, or...
    /*****/ (0, string_1.r) `<[^<>]+>` + // In angle brackets
    /**/ (0, string_1.r) `)` +
    // Title
    /**/ (0, string_1.r) `\s*(?:"[^"]*"|'[^']*'|\([^\(\)]*\))?\s*` +
    (0, string_1.r) `\)`, 'g');
/**
* Matches `[text][ref]` or `[shorthand]`
*/
const referenceLinkPattern = /(^|[^\]\\])(?:(?:(\[((?:\\\]|[^\]])+)\]\[\s*?)([^\s\]]*?)\]|\[\s*?([^\s\\\]]*?)\])(?![\:\(]))/gm;
/**
 * Matches `<http://example.com>`
 */
const autoLinkPattern = /\<(\w+:[^\>\s]+)\>/g;
/**
 * Matches `[text]: link`
 */
const definitionPattern = /^([\t ]*\[(?!\^)((?:\\\]|[^\]])+)\]:\s*)([^<]\S*|<[^>]+>)/gm;
const inlineCodePattern = /(?:^|[^`])(`+)(?:.+?|.*?(?:(?:\r?\n).+?)*?)(?:\r?\n)?\1(?:$|[^`])/gm;
class NoLinkRanges {
    constructor(
    /**
     * code blocks and fences each represented by [line_start,line_end).
     */
    multiline, 
    /**
     * Inline code spans where links should not be detected
     */
    inline) {
        this.multiline = multiline;
        this.inline = inline;
    }
    static async compute(tokenizer, document) {
        const tokens = await tokenizer.tokenize(document);
        const multiline = tokens.filter(t => (t.type === 'code_block' || t.type === 'fence' || t.type === 'html_block') && !!t.map).map(t => t.map);
        const inlineRanges = new Map();
        const text = document.getText();
        for (const match of text.matchAll(inlineCodePattern)) {
            const startOffset = match.index ?? 0;
            const startPosition = document.positionAt(startOffset);
            const range = { start: startPosition, end: document.positionAt(startOffset + match[0].length) };
            for (let line = range.start.line; line <= range.end.line; ++line) {
                let entry = inlineRanges.get(line);
                if (!entry) {
                    entry = [];
                    inlineRanges.set(line, entry);
                }
                entry.push(range);
            }
        }
        return new NoLinkRanges(multiline, inlineRanges);
    }
    contains(position) {
        return this.multiline.some(interval => position.line >= interval[0] && position.line < interval[1]) ||
            !!this.inline.get(position.line)?.some(inlineRange => (0, range_1.rangeContains)(inlineRange, position));
    }
    concatInline(inlineRanges) {
        const newInline = new Map(this.inline);
        for (const range of inlineRanges) {
            for (let line = range.start.line; line <= range.end.line; ++line) {
                let entry = newInline.get(line);
                if (!entry) {
                    entry = [];
                    newInline.set(line, entry);
                }
                entry.push(range);
            }
        }
        return new NoLinkRanges(this.multiline, newInline);
    }
}
/**
 * Stateless object that extracts link information from markdown files.
 */
class MdLinkComputer {
    constructor(tokenizer, workspace) {
        this.tokenizer = tokenizer;
        this.workspace = workspace;
    }
    async getAllLinks(document, token) {
        const noLinkRanges = await NoLinkRanges.compute(this.tokenizer, document);
        if (token.isCancellationRequested) {
            return [];
        }
        const inlineLinks = Array.from(this.getInlineLinks(document, noLinkRanges));
        return Array.from([
            ...inlineLinks,
            ...this.getReferenceLinks(document, noLinkRanges.concatInline(inlineLinks.map(x => x.source.range))),
            ...this.getLinkDefinitions(document, noLinkRanges),
            ...this.getAutoLinks(document, noLinkRanges),
        ]);
    }
    *getInlineLinks(document, noLinkRanges) {
        const text = document.getText();
        for (const match of text.matchAll(linkPattern)) {
            const matchLinkData = extractDocumentLink(document, match[1], match[2], match.index ?? 0, match[0], this.workspace);
            if (matchLinkData && !noLinkRanges.contains(matchLinkData.source.hrefRange.start)) {
                yield matchLinkData;
                // Also check link destination for links
                for (const innerMatch of match[1].matchAll(linkPattern)) {
                    const innerData = extractDocumentLink(document, innerMatch[1], innerMatch[2], (match.index ?? 0) + (innerMatch.index ?? 0), innerMatch[0], this.workspace);
                    if (innerData) {
                        yield innerData;
                    }
                }
            }
        }
    }
    *getAutoLinks(document, noLinkRanges) {
        const text = document.getText();
        for (const match of text.matchAll(autoLinkPattern)) {
            const linkOffset = (match.index ?? 0);
            const linkStart = document.positionAt(linkOffset);
            if (noLinkRanges.contains(linkStart)) {
                continue;
            }
            const link = match[1];
            const linkTarget = resolveLink(document, link, this.workspace);
            if (!linkTarget) {
                continue;
            }
            const linkEnd = (0, position_1.translatePosition)(linkStart, { characterDelta: match[0].length });
            const hrefStart = (0, position_1.translatePosition)(linkStart, { characterDelta: 1 });
            const hrefEnd = (0, position_1.translatePosition)(hrefStart, { characterDelta: link.length });
            yield {
                kind: MdLinkKind.Link,
                href: linkTarget,
                source: {
                    hrefText: link,
                    resource: vscode_uri_1.URI.parse(document.uri),
                    hrefRange: { start: hrefStart, end: hrefEnd },
                    range: { start: linkStart, end: linkEnd },
                    ...getLinkSourceFragmentInfo(document, link, hrefStart, hrefEnd),
                }
            };
        }
    }
    *getReferenceLinks(document, noLinkRanges) {
        const text = document.getText();
        for (const match of text.matchAll(referenceLinkPattern)) {
            const linkStartOffset = (match.index ?? 0) + match[1].length;
            const linkStart = document.positionAt(linkStartOffset);
            if (noLinkRanges.contains(linkStart)) {
                continue;
            }
            let hrefStart;
            let hrefEnd;
            let reference = match[4];
            if (reference === '') { // [ref][],
                reference = match[3];
                const offset = linkStartOffset + 1;
                hrefStart = document.positionAt(offset);
                hrefEnd = document.positionAt(offset + reference.length);
            }
            else if (reference) { // [text][ref]
                const pre = match[2];
                const offset = linkStartOffset + pre.length;
                hrefStart = document.positionAt(offset);
                hrefEnd = document.positionAt(offset + reference.length);
            }
            else if (match[5]) { // [ref]
                reference = match[5];
                const offset = linkStartOffset + 1;
                hrefStart = document.positionAt(offset);
                const line = (0, textDocument_1.getLine)(document, hrefStart.line);
                // See if link looks like a checkbox
                const checkboxMatch = line.match(/^\s*[\-\*]\s*\[x\]/i);
                if (checkboxMatch && hrefStart.character <= checkboxMatch[0].length) {
                    continue;
                }
                hrefEnd = document.positionAt(offset + reference.length);
            }
            else {
                continue;
            }
            const linkEnd = (0, position_1.translatePosition)(linkStart, { characterDelta: match[0].length - match[1].length });
            yield {
                kind: MdLinkKind.Link,
                source: {
                    hrefText: reference,
                    pathText: reference,
                    resource: vscode_uri_1.URI.parse(document.uri),
                    range: { start: linkStart, end: linkEnd },
                    hrefRange: { start: hrefStart, end: hrefEnd },
                    fragmentRange: undefined,
                },
                href: {
                    kind: HrefKind.Reference,
                    ref: reference,
                }
            };
        }
    }
    *getLinkDefinitions(document, noLinkRanges) {
        const text = document.getText();
        for (const match of text.matchAll(definitionPattern)) {
            const offset = (match.index ?? 0);
            const linkStart = document.positionAt(offset);
            if (noLinkRanges.contains(linkStart)) {
                continue;
            }
            const pre = match[1];
            const reference = match[2];
            const rawLinkText = match[3].trim();
            const target = resolveLink(document, rawLinkText, this.workspace);
            if (!target) {
                continue;
            }
            const isAngleBracketLink = angleBracketLinkRe.test(rawLinkText);
            const linkText = stripAngleBrackets(rawLinkText);
            const hrefStart = (0, position_1.translatePosition)(linkStart, { characterDelta: pre.length + (isAngleBracketLink ? 1 : 0) });
            const hrefEnd = (0, position_1.translatePosition)(hrefStart, { characterDelta: linkText.length });
            const hrefRange = { start: hrefStart, end: hrefEnd };
            const refStart = (0, position_1.translatePosition)(linkStart, { characterDelta: 1 });
            const refRange = { start: refStart, end: (0, position_1.translatePosition)(refStart, { characterDelta: reference.length }) };
            const linkEnd = (0, position_1.translatePosition)(linkStart, { characterDelta: match[0].length });
            yield {
                kind: MdLinkKind.Definition,
                source: {
                    hrefText: linkText,
                    resource: vscode_uri_1.URI.parse(document.uri),
                    range: { start: linkStart, end: linkEnd },
                    hrefRange,
                    ...getLinkSourceFragmentInfo(document, rawLinkText, hrefStart, hrefEnd),
                },
                ref: { text: reference, range: refRange },
                href: target,
            };
        }
    }
}
exports.MdLinkComputer = MdLinkComputer;
class LinkDefinitionSet {
    constructor(links) {
        this._map = new Map();
        for (const link of links) {
            if (link.kind === MdLinkKind.Definition) {
                this._map.set(link.ref.text, link);
            }
        }
    }
    [Symbol.iterator]() {
        return this._map.entries();
    }
    lookup(ref) {
        return this._map.get(ref);
    }
}
exports.LinkDefinitionSet = LinkDefinitionSet;
/**
 * Stateful object which provides links for markdown files the workspace.
 */
class MdLinkProvider extends dispose_1.Disposable {
    constructor(tokenizer, _workspace, _tocProvider, logger) {
        super();
        this._workspace = _workspace;
        this._tocProvider = _tocProvider;
        this._linkComputer = new MdLinkComputer(tokenizer, _workspace);
        this._linkCache = this._register(new workspaceCache_1.MdDocumentInfoCache(this._workspace, async (doc) => {
            logger.log(logging_1.LogLevel.Debug, 'LinkProvider', `compute - ${doc.uri}`);
            const links = await this._linkComputer.getAllLinks(doc, cancellation_1.noopToken);
            return {
                links,
                definitions: new LinkDefinitionSet(links),
            };
        }));
    }
    getLinks(document) {
        return this._linkCache.getForDocument(document);
    }
    async provideDocumentLinks(document, token) {
        const { links, definitions } = await this.getLinks(document);
        if (token.isCancellationRequested) {
            return [];
        }
        return (0, arrays_1.coalesce)(links.map(data => this.toValidDocumentLink(data, definitions)));
    }
    async resolveDocumentLink(link, _token) {
        if (!link.data) {
            return undefined;
        }
        const mdLink = link.data;
        if (mdLink.href.kind !== HrefKind.Internal) {
            return undefined;
        }
        // Default to allowing to click link to goto / create file
        link.target = this.createCommandUri('vscode.open', mdLink.href.path);
        let target = vscode_uri_1.URI.from(mdLink.href.path);
        const stat = await this._workspace.stat(target);
        if (stat?.isDirectory) {
            link.target = this.createCommandUri('revealInExplorer', mdLink.href.path);
            return link;
        }
        if (!stat) {
            // We don't think the file exists. If it doesn't already have an extension, try tacking on a `.md` and using that instead
            let found = false;
            if (vscode_uri_1.Utils.extname(target) === '') {
                const dotMdResource = target.with({ path: target.path + '.md' });
                if (await this._workspace.stat(dotMdResource)) {
                    target = dotMdResource;
                    found = true;
                }
            }
            if (!found) {
                return link;
            }
        }
        if (!mdLink.href.fragment) {
            link.target = this.createCommandUri('vscode.open', target);
            return link;
        }
        // Try navigating with fragment that sets line number
        const lineNumberFragment = mdLink.href.fragment.match(/^L(\d+)(?:,(\d+))?$/i);
        if (lineNumberFragment) {
            const line = +lineNumberFragment[1] - 1;
            if (!isNaN(line)) {
                const char = +lineNumberFragment[2] - 1;
                const pos = { line, character: isNaN(char) ? 0 : char };
                link.target = this.createOpenAtPosCommand(target, pos);
                return link;
            }
        }
        // Try navigating to header in file
        const doc = await this._workspace.openMarkdownDocument(target);
        if (doc) {
            const toc = await this._tocProvider.getForDocument(doc);
            const entry = toc.lookup(mdLink.href.fragment);
            if (entry) {
                link.target = this.createOpenAtPosCommand(target, entry.headerLocation.range.start);
                return link;
            }
        }
        link.target = this.createCommandUri('vscode.open', target);
        return link;
    }
    toValidDocumentLink(link, definitionSet) {
        switch (link.href.kind) {
            case HrefKind.External: {
                return {
                    range: link.source.hrefRange,
                    target: link.href.uri.toString(true),
                };
            }
            case HrefKind.Internal: {
                return {
                    range: link.source.hrefRange,
                    target: undefined,
                    tooltip: 'Follow link',
                    data: link,
                };
            }
            case HrefKind.Reference: {
                // We only render reference links in the editor if they are actually defined.
                // This matches how reference links are rendered by markdown-it.
                const def = definitionSet.lookup(link.href.ref);
                if (!def) {
                    return undefined;
                }
                const target = this.createOpenAtPosCommand(link.source.resource, def.source.hrefRange.start);
                return {
                    range: link.source.hrefRange,
                    tooltip: localize('definition.tooltip', 'Go to link definition'),
                    target: target,
                    data: link
                };
            }
        }
    }
    createCommandUri(command, ...args) {
        return `command:${command}?${encodeURIComponent(JSON.stringify(args))}`;
    }
    createOpenAtPosCommand(resource, pos) {
        // Workaround https://github.com/microsoft/vscode/issues/154993
        return this.createCommandUri('_workbench.open', resource, [undefined, {
                selection: {
                    startLineNumber: pos.line + 1,
                    startColumn: pos.character + 1,
                    endLineNumber: pos.line + 1,
                    endColumn: pos.character + 1,
                }
            }]);
    }
}
exports.MdLinkProvider = MdLinkProvider;
function createWorkspaceLinkCache(parser, workspace) {
    const linkComputer = new MdLinkComputer(parser, workspace);
    return new workspaceCache_1.MdWorkspaceInfoCache(workspace, doc => linkComputer.getAllLinks(doc, cancellation_1.noopToken));
}
exports.createWorkspaceLinkCache = createWorkspaceLinkCache;
//# sourceMappingURL=documentLinks.js.map