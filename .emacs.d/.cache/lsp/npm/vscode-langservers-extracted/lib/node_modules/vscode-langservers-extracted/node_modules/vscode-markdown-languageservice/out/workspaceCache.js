"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.MdWorkspaceInfoCache = exports.MdDocumentInfoCache = void 0;
const vscode_uri_1 = require("vscode-uri");
const dispose_1 = require("./util/dispose");
const lazy_1 = require("./util/lazy");
const resourceMap_1 = require("./util/resourceMap");
class LazyResourceMap {
    constructor() {
        this._map = new resourceMap_1.ResourceMap();
    }
    has(resource) {
        return this._map.has(resource);
    }
    get(resource) {
        return this._map.get(resource)?.value;
    }
    set(resource, value) {
        this._map.set(resource, value);
    }
    delete(resource) {
        this._map.delete(resource);
    }
    entries() {
        return Promise.all(Array.from(this._map.entries(), async ([key, entry]) => {
            return [key, await entry.value];
        }));
    }
}
/**
 * Cache of information per-document in the workspace.
 *
 * The values are computed lazily and invalidated when the document changes.
 */
class MdDocumentInfoCache extends dispose_1.Disposable {
    constructor(workspace, getValue) {
        super();
        this.workspace = workspace;
        this.getValue = getValue;
        this._cache = new LazyResourceMap();
        this._loadingDocuments = new resourceMap_1.ResourceMap();
        this._register(this.workspace.onDidChangeMarkdownDocument(doc => this.invalidate(doc)));
        this._register(this.workspace.onDidDeleteMarkdownDocument(this.onDidDeleteDocument, this));
    }
    async get(resource) {
        let existing = this._cache.get(resource);
        if (existing) {
            return existing;
        }
        const doc = await this.loadDocument(resource);
        if (!doc) {
            return undefined;
        }
        // Check if we have invalidated
        existing = this._cache.get(resource);
        if (existing) {
            return existing;
        }
        return this.resetEntry(doc)?.value;
    }
    async getForDocument(document) {
        const existing = this._cache.get(vscode_uri_1.URI.parse(document.uri));
        if (existing) {
            return existing;
        }
        return this.resetEntry(document).value;
    }
    loadDocument(resource) {
        const existing = this._loadingDocuments.get(resource);
        if (existing) {
            return existing;
        }
        const p = this.workspace.openMarkdownDocument(resource);
        this._loadingDocuments.set(resource, p);
        p.finally(() => {
            this._loadingDocuments.delete(resource);
        });
        return p;
    }
    resetEntry(document) {
        const value = (0, lazy_1.lazy)(() => this.getValue(document));
        this._cache.set(vscode_uri_1.URI.parse(document.uri), value);
        return value;
    }
    invalidate(document) {
        if (this._cache.has(vscode_uri_1.URI.parse(document.uri))) {
            this.resetEntry(document);
        }
    }
    onDidDeleteDocument(resource) {
        this._cache.delete(resource);
    }
}
exports.MdDocumentInfoCache = MdDocumentInfoCache;
/**
 * Cache of information across all markdown files in the workspace.
 *
 * Unlike {@link MdDocumentInfoCache}, the entries here are computed eagerly for every file in the workspace.
 * However the computation of the values is still lazy.
 */
class MdWorkspaceInfoCache extends dispose_1.Disposable {
    constructor(workspace, getValue) {
        super();
        this.workspace = workspace;
        this.getValue = getValue;
        this._cache = new LazyResourceMap();
    }
    async entries() {
        await this.ensureInit();
        return this._cache.entries();
    }
    async values() {
        await this.ensureInit();
        return Array.from(await this._cache.entries(), x => x[1]);
    }
    async getForDocs(docs) {
        for (const doc of docs) {
            if (!this._cache.has(vscode_uri_1.URI.parse(doc.uri))) {
                this.update(doc);
            }
        }
        return Promise.all(docs.map(doc => this._cache.get(vscode_uri_1.URI.parse(doc.uri))));
    }
    async ensureInit() {
        if (!this._init) {
            this._init = this.populateCache();
            this._register(this.workspace.onDidChangeMarkdownDocument(this.onDidChangeDocument, this));
            this._register(this.workspace.onDidCreateMarkdownDocument(this.onDidChangeDocument, this));
            this._register(this.workspace.onDidDeleteMarkdownDocument(this.onDidDeleteDocument, this));
        }
        await this._init;
    }
    async populateCache() {
        const markdownDocumentUris = await this.workspace.getAllMarkdownDocuments();
        for (const document of markdownDocumentUris) {
            if (!this._cache.has(vscode_uri_1.URI.parse(document.uri))) {
                this.update(document);
            }
        }
    }
    update(document) {
        this._cache.set(vscode_uri_1.URI.parse(document.uri), (0, lazy_1.lazy)(() => this.getValue(document)));
    }
    onDidChangeDocument(document) {
        this.update(document);
    }
    onDidDeleteDocument(resource) {
        this._cache.delete(resource);
    }
}
exports.MdWorkspaceInfoCache = MdWorkspaceInfoCache;
//# sourceMappingURL=workspaceCache.js.map