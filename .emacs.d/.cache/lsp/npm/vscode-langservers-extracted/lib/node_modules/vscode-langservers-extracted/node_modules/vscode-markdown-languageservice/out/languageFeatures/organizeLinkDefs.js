"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.MdOrganizeLinkDefinitionProvider = void 0;
const range_1 = require("../types/range");
const string_1 = require("../util/string");
const documentLinks_1 = require("./documentLinks");
class MdOrganizeLinkDefinitionProvider {
    constructor(_linkProvider) {
        this._linkProvider = _linkProvider;
    }
    async getOrganizeLinkDefinitionEdits(doc, token) {
        const links = await this._linkProvider.getLinks(doc);
        if (token.isCancellationRequested) {
            return [];
        }
        const definitions = links.links.filter(link => link.kind === documentLinks_1.MdLinkKind.Definition);
        if (!definitions.length) {
            return [];
        }
        // Check if we are already sorted
        if (definitions.every((def, i) => {
            const next = definitions[i + 1];
            return !next || def.ref.text.localeCompare(next.ref.text) < 0;
        })) {
            return [];
        }
        const defBlockStart = this.getStartOfDefinitionBlock(doc, definitions);
        const sortedDefs = [...definitions];
        sortedDefs.sort((a, b) => a.ref.text.localeCompare(b.ref.text));
        const edits = [];
        for (let i = 0; i < sortedDefs.length; ++i) {
            const def = sortedDefs[i];
            const startLine = defBlockStart.line + i;
            edits.push({
                newText: `[${def.ref.text}]: ${def.source.hrefText}` + (i === sortedDefs.length - 1 ? '' : '\n'),
                range: (0, range_1.makeRange)(startLine, 0, startLine, Infinity),
            });
        }
        return edits;
    }
    getStartOfDefinitionBlock(doc, definitions) {
        const lastDef = definitions[definitions.length - 1];
        const textAfter = doc.getText((0, range_1.makeRange)(lastDef.source.range.end.line + 1, 0, Infinity, 0));
        if ((0, string_1.isEmptyOrWhitespace)(textAfter)) {
            return lastDef.source.range.start;
        }
        return lastDef.source.range.start;
    }
}
exports.MdOrganizeLinkDefinitionProvider = MdOrganizeLinkDefinitionProvider;
//# sourceMappingURL=organizeLinkDefs.js.map