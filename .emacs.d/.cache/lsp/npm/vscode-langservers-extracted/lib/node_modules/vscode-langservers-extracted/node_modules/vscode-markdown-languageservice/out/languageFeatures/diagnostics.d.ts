import { CancellationToken, Event } from 'vscode-languageserver';
import * as lsp from 'vscode-languageserver-types';
import { URI } from 'vscode-uri';
import { LsConfiguration } from '../config';
import { MdTableOfContentsProvider } from '../tableOfContents';
import { ITextDocument } from '../types/textDocument';
import { Disposable, IDisposable } from '../util/dispose';
import { ResourceMap } from '../util/resourceMap';
import { IWorkspace, IWorkspaceWithWatching as IWorkspaceWithFileWatching } from '../workspace';
import { MdLink, MdLinkProvider } from './documentLinks';
export declare enum DiagnosticLevel {
    ignore = "ignore",
    warning = "warning",
    error = "error"
}
export interface DiagnosticOptions {
    readonly validateReferences: DiagnosticLevel | undefined;
    readonly validateFragmentLinks: DiagnosticLevel | undefined;
    readonly validateFileLinks: DiagnosticLevel | undefined;
    readonly validateMarkdownFileLinkFragments: DiagnosticLevel | undefined;
    readonly ignoreLinks: readonly string[];
}
export declare enum DiagnosticCode {
    link_noSuchReferences = "link.no-such-reference",
    link_noSuchHeaderInOwnFile = "link.no-such-header-in-own-file",
    link_noSuchFile = "link.no-such-file",
    link_noSuchHeaderInFile = "link.no-such-header-in-file"
}
export declare class DiagnosticComputer {
    private readonly configuration;
    private readonly workspace;
    private readonly linkProvider;
    private readonly tocProvider;
    constructor(configuration: LsConfiguration, workspace: IWorkspace, linkProvider: MdLinkProvider, tocProvider: MdTableOfContentsProvider);
    compute(doc: ITextDocument, options: DiagnosticOptions, token: CancellationToken): Promise<{
        readonly diagnostics: lsp.Diagnostic[];
        readonly links: readonly MdLink[];
        readonly statCache: ResourceMap<{
            readonly exists: boolean;
        }>;
    }>;
    private validateFragmentLinks;
    private validateReferenceLinks;
    private validateFileLinks;
    private isMarkdownPath;
    private isIgnoredLink;
}
/**
 * Stateful object that can more efficiently compute diagnostics for the workspace.
 */
export interface IPullDiagnosticsManager extends IDisposable {
    readonly onLinkedToFileChanged: Event<{
        readonly changedResource: URI;
        readonly linkingResources: readonly URI[];
    }>;
    /**
     * Compute the current diagnostics for a file.
     */
    computeDiagnostics(doc: ITextDocument, options: DiagnosticOptions, token: CancellationToken): Promise<lsp.Diagnostic[]>;
}
export declare class DiagnosticsManager extends Disposable implements IPullDiagnosticsManager {
    private readonly _computer;
    private readonly _linkWatcher;
    private readonly _onLinkedToFileChanged;
    readonly onLinkedToFileChanged: Event<{
        readonly changedResource: URI;
        readonly linkingResources: readonly URI[];
    }>;
    constructor(configuration: LsConfiguration, workspace: IWorkspaceWithFileWatching, linkProvider: MdLinkProvider, tocProvider: MdTableOfContentsProvider);
    computeDiagnostics(doc: ITextDocument, options: DiagnosticOptions, token: CancellationToken): Promise<lsp.Diagnostic[]>;
}
